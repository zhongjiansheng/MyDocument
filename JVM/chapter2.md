#### Java内存划分

* 线程私有

  1. 程序计数器

     当前线程所执行的字节码的行号指示器。 ==分支、跳转、循环、异常处理、线程恢复==等基础功能都依赖这个计数器

  2. Java虚拟机栈

     ==java方法执行==的内存模型。用于存储局部变量表、操作数栈、动态链接、方法出口等信息

  3. 本地方法栈

     虚拟机栈为Java方法服务，本地方法栈为Native方法服务。

* 线程共享

  1. java堆

     存放==对象实例以及数组分配==，该区域也被称为==GC堆==。该堆**收集器**采用==分代收集算法（新生代、老年代）==

  2. 方法区

     存放虚拟机加载的==类信息、常量、静态变量，即使编译器编译后的代码==

  3. 运行时常量池

     方法区的一部分，用来存放编译器生成的各种字面量和符号引用



#### 对象创建

* 创建过程
  1. 遇到==new==指令，检查该指令的参数是否能在常量池定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化。
  2. 如果没则进行相应的类加载过程。
  3. 为新生对象分配内存
* 内存分配方法
  1. java堆规整则采用==指针碰撞==
  2. java堆不规整则采用==空闲列表==



#### 对象的内存布局

* 对象头

  存放对象自身的运行时数据，如==哈希码、GC年龄分代、锁状态标志、线程持有的锁==

* 实例数据

  存放对象真正存储的有效信息

* 对齐填充

  HotSpot VM的自动内存管理系统要求对象起始地址必须时8字节的整数倍。



#### 对象的访问定位

* 句柄

  稳定，当对象被移动的时候，只会改变句柄中的实例数据指针，而引用本身不用修改

* 直接指针

  速度块，节省了一次指针定位的时间开销

**注意：**OutOfMemoryError又称为==OOM==

