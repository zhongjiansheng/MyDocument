## 值传递和引用传递

java中的传递都是值传递，只不过这个值是传递的数值还是对象的引用。

如果传递的是副本则不会对原有值进行修改，如果传递的不是副本，则看地址是否改变，改变则不会修改原有地址的值。

## 多态

运行时绑定，能够动态的是实例化具体类。

多态只有通过类（抽象类）继承或者接口实现的，才能进行多态。

`继承的初始化顺序：`先基类以及成员初始化，最后才是自己类初始化。

`继承的销毁顺序：`和初始化顺序相反。因为导出类的清理可能会调用基类的方法



## 关系运算符

Integer等包装类型具有自己的缓存区间，当在缓存区间时不会重新创建对象，所以虽然包装类型是引用类型，当使用`==`仍然相等。

## ==和equal的区别

==是对引用进行对比，equal用来进行内容的对比，但需要重写，因为默认也是引用对比。

## this关键词

==this==关键词只能在非静态方法内部使用，用来指代方法调用的对象

## 垃圾回收器

垃圾回收器只能回收内存中通过==new==创建的对象，如果是其他方式分配的内存对象则需要通过`finalize`进行释放

**注意:**1.对象可能不被垃圾回收器回收

​          2.垃圾回收不等于析构

## JIT（Just-In-Time）

把程序全部或部分翻译成本地机器码，不需要 JVM 来进行翻译。当需要装载某个类时，首先找到该类的`.class`文件，然后将字节码装入内存中。如果编码所有代码，会存在两个缺点：

1. 加载动作贯穿整个程序生命周期内，累加起来需要花更多时间
2. 增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多）

## 初始化顺序

**普通类：**静态变量\静态块 ->main方法->块\变量初始化->构造方法

**继承类：**父类静态变量、静态块 ->子类静态变量、静态块->子类main方法->父类变量、初始化块->父类构造方法->子类变量、初始化块->子类构造器



