#### 类的生命周期

加载、连接（验证、准备、解析）、初始化、使用、卸载



#### 类加载时机

* 主动引用，进行初始化

1. 使用new关键词实例化对象、读取或者设置一个类的静态字段、调用一个类的静态方法的时候
2. 使用java.lang.reflect包的方法对类进行反射调用的时候
3. 当初始化一个类的时候，如果发现父类没有初始化，则先触发父类的初始化
4. 当虚拟机启动时，用户需要指定一个需要执行的主类
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic的方法句柄，并且该句柄所对应的类没有进行过初始化

* 被动引用，不会触发初始化
  1. 调用父类的静态方法或者字段，只会初始化父类
  2. 通过数组定义来引用类，不会触发此类的初始化
  3. 常量在编译阶段会存入类的常量池



#### 类加载的过程

* 加载

  虚拟机需要完成以下3件事情：

  1. 通过一个类的全限定名来获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口

* 验证

  确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

  1. 文件格式验证（把字节流存入内存的方法区，后面三个验证就基于方法区的存储结构进行）

     > 是否以魔数0xCAFEBABE开头
     >
     > 主、次版本号是否在当前虚拟机处理范围之内
     >
     > 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）
     >
     > 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的变量

  2. 元数据验证

     对字节码描述的信息进行语义分析

     > 这个类是否有父类（除了java.lang.object之外，所有类都应当有父类）
     >
     > 这个类的父类是否继承了不允许被继承的类
     >
     > 如果这个类不是抽象类，是否实现了其父类或接口之外要求实现的所有方法

  3. 字节码验证

     对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事情

  4. 符号引用验证

* 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，==类变量是指被static修饰的变量==。如果变量用了==final==修饰，则在准备阶段就把变量赋值为指定值.

* 解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

* 初始化

  初始化阶段是执行类构造器<clinit>方法的过程。

  > <clinit>是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。
  >
  > <clinit>方法与类的构造器不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。因此在虚拟机中第一个被执行地<clinit>（）方法地类肯定是java.lang.object
  >
  > <clinit>在接口执行不一定先执行父接口地<clinit>，只有当父接口中定义的变量使用时，才会初始化。同样，接口的实现类在初始化时也一样不会执行接口的<clinit>方法
  >
  > 虚拟机会保证一个类地<clinit>方法在多线程环境中被正确地加锁、同步，如果多个线程同时区初始化一个类，只有一个线程会执行，其余则阻塞等待



#### 类加载器

用于对实现类进行加载

* 类与类加载器

  任意一个类都需要由加载它地类加载器和这个类本身一同确立其在java虚拟机中的唯一性。

* 类加载器的分类

  1. 启动类加载器
  2. 扩展类加载器
  3. 应用程序类加载器（系统类加载器）

* 双亲委派模式

  类加载器之间的父子关系时使用组合。

* 破坏双亲委派模型

  