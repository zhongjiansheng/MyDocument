#### 局部变量表

一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽位最小单位。

> Slot应该能存放boolean、byte、char、short、int、float、reference类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放。
>
> 在64位虚拟机中使用64位物理内存空间去实现一个Slot，虚拟机需要使用对齐和补白的手段让Slot外观看起来与32位虚拟机中一致
>
> 

虚拟机通过==索引定位==的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot

#### 操作数栈

每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）。操作数栈和局部变量表在访问方式上存在着较大差异，操作数栈并非采用访问索引的方式来进行数据访问的，而是通过标准的入栈和出栈操作来完成一次数据访问。每一个操作数栈都会拥有一个明确的栈深度用于存储数值，一个32bit的数值可以用一个单位的栈深度来存储，而2个单位的栈深度则可以保存一个64bit的数值，当然操作数栈所需的容量大小在编译期就可以被完全确定下来，并保存在方法的Code属性中。

#### 动态连接

每个栈帧都包含一个指向运行时常量池中栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接

#### 方法返回地址

* 正常完成出口

  执行引擎遇到任意一个方法返回的字节码指令

* 异常完成出口

#### 方法调用

确定被调用方法的版本（即调用哪个方法），暂时还不涉及方法内部的具体运行过程

* 解析

  在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个确定的调用版本，并且这个方法的版本在运气行不可变。主要包括：静态方法、私有方法

* 分派

  1. 静态分派

     典型应用是==方法重载==。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

  2. 动态分派