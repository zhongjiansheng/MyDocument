#### 对象存活判定方法

* 引用计数算法
  每个对象都有一个引用计数器，每当一个地方引用该对象的时候都会计数值加1；当引用失效后则减1；==缺点:==无法解决循环依赖的问题
  
* 可达性分析算法

  通过一系列"GC Roots"的对象为起始点，从这些节点出发进行搜索；

  > GC Roots:1.虚拟机栈中引用的对象
  >
  > ​                 2.方法区中类静态属性引用的对象
  >
  > ​                 3.方法区中常量引用的对象
  >
  > ​                 4.本地方法栈中JNI引用的对象



#### 引用类型分类

* 强引用 
* 软引用
* 弱引用
* 虚引用



#### 回收方法区

* 无用类判定方法
  1. 该类所有实例都已经被回收
  2. 加载该类的ClassLoader已经被回收
  3. 该类对应的java.lang.class对象没有在任何地方被引用



#### 垃圾收集算法

* 标记-清除

  缺点：效率低，内存碎片

* 复制算法

  缺点：需要把内存缩小一半，每次只使用一半，该内存使用完后则把存活的对象复制到另一半上

  优点：不用担心碎片清理，效率比标记-清除高

* 标记-整理算法

  标记步骤和标记-清除一样，后续步骤时把存活的对象都向一端移动。

* 分代收集算法

  1. 新生代

     由于每次垃圾收集时都有大批对象死去，可以采用复制算法

  2. 老年代

     对象存活率较高，没有额外空间对它进行担保，使用标记-清理、标记-整理算法



#### 收集器

* 新生代

  1. Serial收集器

     单线程收集垃圾

  2. ParNew收集器

     多线程收集垃圾

  3. Parallel Scavenge收集器

     专注于==吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间 ）==。能够自动调优

* 老年代

  1. Serial Old收集器

     单线程收集垃圾

  2. Parallel Old收集器

     多线程收集垃圾

  3. CMS收集器

     以获取最短回收停顿时间为目标

     > 基于标记-清除:
     >
     > 1. 初始标记：也会导致用户线程停止
     > 2. 并发标记：进行GC Roots Tracing
     > 3. 重新标记：也会导致用户线程停止，用于修正并发标记期间用户程序运作而导致标记产生变动，比初始标记时间长，但比并发标记时间短
     > 4. 并发清除

     **缺点：**1.CPU资源敏感，特别是CPU数量低于2的时候；2.因为浮动垃圾可能导致FULL GC的产生；3.产生不连续的内存碎片

* G1收集器

  可以对整个GC堆进行管理



#### 理解GC日志

GC发生的时间----> 垃圾收集的停顿类型---->GC发生的区域---->GC前该内存区域已使用容量-GC后该内存区域已使用容量（该内存区域总容量）---->GC前Java堆已使用容量-GC后Java堆已使用容量（java堆总容量）---->GC所占用时间

**注意：**==Full GC 和 Minor GC==的区别

> Minor GC:发生在新生代的垃圾收集动作。发生频繁
>
> Full GC:发生在老年代的GC，出现Full GC则必有一次Minor GC



#### 判别对象年龄

每个对象都又一个==对象年龄计数器==，如果对象在Eden出生并经过第一次Minor GC后仍然存活，对象年龄都会增加1。熬过设置的年龄阙值后，就会移动到老年代。年龄阙值可以通过==-XX:MaxTenuringThreshold==设置

* 动态对象判定

  Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半。



#### 空间分配担保

1. 发生Minor GC之前，检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
2. 如果成立，则Minor GC可以确保安全
3. 如果不成立，则虚拟机查看==HandlePromotionFailure==设置值是否允许担保失败。如果允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，则尝试一次Minor GC,这次Minor GC是有风险的。如果小于，或者HandlePromotionFailure设置不允许冒险，则这时要Full GC。